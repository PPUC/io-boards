.program active_low_16_switches_pio
.side_set 4 opt
    ; Initialize X to all pins HIGH
    set x, 0         ; X = 0x0
    mov y, ~x        ; Y = 0xFFFFFFFF
    mov x, y         ; X = 0xFFFFFFFF
    mov osr, y       ; OSR = 0xFFFFFFFF

loop:
    set y, 0         ; X = 0x0
    mov isr, ~y      ; ISR = 0xFFFFFFFF
    in pins, 16      ; read 16 switches to ISR (filling lower 16 bits of the 32bit ISR)

    mov y, isr       ; copy ISR to Y for comparison
    jmp x!=y changed ; jump to "changed" if X (old state) != Y (new state)

    ; two consecutive identical reads required for debouncing
    mov y, osr       ; copy OSR to Y for comparison
    jmp x!=y new_stable_state

    jmp loop

changed:
    mov x, isr       ; update X to the new state
    nop              ; short delay for debouncing
    nop              ; short delay for debouncing
    nop              ; short delay for debouncing
    nop              ; short delay for debouncing
    nop              ; short delay for debouncing
    nop              ; short delay for debouncing
    jmp loop

new_stable_state:
    mov osr, isr     ; update OSR to the new state, used for debouncing
    push block       ; push ISR to FIFO, "block" waits until the CPU handled enough data in the FIFO, so we don't overflow it, ISR is empty after that!
    irq 1            ; trigger interrupt 1 to notify the main CPU that switches changed

    ; Reset stateful pins (GPIO 15-18)
    set pindirs, 0b1111                 ; change direction of 4 pins (15-18) to output
    nop                     side 0      ; set LOW
    nop                     side 0b1111 ; set 4 pins to HIGH
    nop                     side 0b1111 ; short delay
    nop                     side 0b1111 ; short delay
    nop                     side 0b1111 ; short delay
    nop                     side 0      ; set LOW
    set pindirs, 0                      ; change direction all pins back to input

    jmp loop
