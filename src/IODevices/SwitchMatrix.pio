.program columns_active_high_pio
.wrap_target
    set x, 1
    mov isr, x       ; initialize ISR with 0x00000001
    set x, 0         ; X = 0
    set y, 7         ; 8 columns (0-7)

loop:
    mov osr, isr     ; copy ISR to OSR for output
    out pins, 8      ; set 8 pins for columns, one is HIGH, others LOW
    in x, 1          ; shift left ISR by 1 bit
    nop [16]         ; short delay to let other state machines read rows
    jmp y-- loop     ; decrement Y, loop until Y < 0
.wrap


.program odd_rows_active_high_pio
    ; Initialize X to all pins LOW. Max. 4x8 rows, so 32 bit, so 0x0:
    set x, 0         ; X = 0x0
    mov y, x         ; Y = 0x0
    mov isr, y       ; ISR = 0x0

loop:
    wait 0 PIN 8     ; wait for odd column 1
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)
    wait 0 PIN 10    ; wait for odd column 3
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)
    wait 0 PIN 12    ; wait for odd column 5
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)
    wait 0 PIN 14    ; wait for odd column 7
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)

    mov y, isr       ; copy ISR to Y for comparison
    jmp x!=y changed ; jump to "changed" if X (old state) != Y (new state)
    jmp loop

changed:
    mov osr, y
    push block       ; push OSR to FIFO, "block" waits until the CPU handled enough data in the FIFO, so we don't overflow it
    irq 0            ; trigger interrupt 0 to notify the main CPU that a odd columns state has changed
    mov x, y         ; update X to the new odd columns state
    jmp loop


.program even_rows_active_high_pio
    ; Initialize X to all pins LOW. Max. 4x8 rows, so 32 bit, so 0x0:
    set x, 0         ; X = 0x0
    mov y, x         ; Y = 0x0
    mov isr, y       ; ISR = 0x0

loop:
    wait 0 PIN 9     ; wait for even column 2
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)
    wait 0 PIN 11    ; wait for even column 4
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)
    wait 0 PIN 13    ; wait for even column 6
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)
    wait 0 PIN 15    ; wait for even column 8
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)

    mov y, isr       ; copy ISR to Y for comparison
    jmp x!=y changed ; jump to "changed" if X (old state) != Y (new state)
    jmp loop

changed:
    mov osr, y
    push block       ; push OSR to FIFO, "block" waits until the CPU handled enough data in the FIFO, so we don't overflow it
    irq 1            ; trigger interrupt 1 to notify the main CPU that a even columns state has changed
    mov x, y         ; update X to the new switch states
    jmp loop


; ----------------------------------------------------------------------------------------------------------------------------
; ----------------------------------------------------------------------------------------------------------------------------


.program columns_active_low_pio
.wrap_target
    set y, 1
    mov isr, ~y      ; initialize ISR with 0xFFFFFFFE
    set y, 0         ; Y = 0
    mov x, ~y        ; X = 0xFFFFFFFF
    set y, 7         ; 8 columns (0-7)

loop:
    mov osr, isr     ; copy ISR to OSR for output
    out pins, 8      ; set 8 pins for columns, one is HIGH, others LOW
    in x, 1          ; shift left ISR by 1 bit
    nop [16]         ; short delay to let other state machines read rows
    jmp y-- loop     ; decrement Y, loop until Y < 0
.wrap


.program odd_rows_active_low_pio
    ; Initialize X to all pins HIGH. Max. 4x8 rows, so 32 bit:
    set x, 0         ; X = 0x0
    mov y, ~x        ; Y = 0xFFFFFFFF
    mov x, y         ; X = 0xFFFFFFFF
    mov isr, y       ; ISR = 0xFFFFFFFF

loop:
    wait 0 PIN 8     ; wait for odd column 1
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)
    wait 0 PIN 10    ; wait for odd column 3
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)
    wait 0 PIN 12    ; wait for odd column 5
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)
    wait 0 PIN 14    ; wait for odd column 7
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)

    mov y, isr       ; copy ISR to Y for comparison
    jmp x!=y changed ; jump to "changed" if X (old state) != Y (new state)
    jmp loop

changed:
    mov osr, y
    push block       ; push OSR to FIFO, "block" waits until the CPU handled enough data in the FIFO, so we don't overflow it
    irq 0            ; trigger interrupt 0 to notify the main CPU that a odd columns state has changed
    mov x, y         ; update X to the new odd columns state
    jmp loop


.program even_rows_active_low_pio
    ; Initialize X to all pins HIGH. Max. 4x8 rows, so 32 bit:
    set x, 0         ; X = 0x0
    mov y, ~x        ; Y = 0xFFFFFFFF
    mov x, y         ; X = 0xFFFFFFFF
    mov isr, y       ; ISR = 0xFFFFFFFF

loop:
    wait 0 PIN 9     ; wait for even column 2
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)
    wait 0 PIN 11    ; wait for even column 4
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)
    wait 0 PIN 13    ; wait for even column 6
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)
    wait 0 PIN 15    ; wait for even column 8
    in pins, 8       ; read 8 rows to ISR (shifting into lower 8 bits of the 32bit ISR)

    mov y, isr       ; copy ISR to Y for comparison
    jmp x!=y changed ; jump to "changed" if X (old state) != Y (new state)
    jmp loop

changed:
    mov osr, y
    push block       ; push OSR to FIFO, "block" waits until the CPU handled enough data in the FIFO, so we don't overflow it
    irq 1            ; trigger interrupt 1 to notify the main CPU that a even columns state has changed
    mov x, y         ; update X to the new switch states
    jmp loop
